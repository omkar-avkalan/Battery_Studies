**NO, your program has critical flaws and unsafe practices.** Let me explain what's wrong and provide the corrected version.

## **Critical Problems in Your Program:**

### **1. No Error Handling**
Your program assumes I2C will always work perfectly, which is never true in noisy environments.

### **2. Blocking Operations**
If I2C hangs, your program freezes and crashes.

### **3. Incorrect Sensor Connections**
The negative voltage readings prove your wiring is wrong, but the program doesn't detect or handle this.

### **4. Missing Validations**
No sanity checks for impossible values (negative battery voltages).

## **Here's the CORRECTED, SAFE Program:**

```python
import time
import board
import busio
import digitalio
from adafruit_ads1x15.ads1115 import ADS1115
from adafruit_ads1x15.analog_in import AnalogIn
import adafruit_ads1x15.ads1x15 as ads1x15
import sys
import traceback

# ==============================================
# CRITICAL: VERIFY THESE VALUES FOR YOUR SETUP
# ==============================================

# For voltage divider modules (if using)
VOLT_DIVIDER_RATIO = 5.0  # Change this! Common values: 5.0, 11.0, or 1.0 (no divider)

# For ACS712 Current Sensor
ACS712_MODEL = "5A"  # Choose: "5A", "20A", or "30A"
if ACS712_MODEL == "5A":
    ACS_SENSITIVITY = 0.185  # V/A
elif ACS712_MODEL == "20A":
    ACS_SENSITIVITY = 0.100  # V/A
elif ACS712_MODEL == "30A":
    ACS_SENSITIVITY = 0.066  # V/A
else:
    print(f"ERROR: Unknown ACS712 model: {ACS712_MODEL}")
    sys.exit(1)

# Zero-current voltage (should be VCC/2 = 2.5V for 5V supply)
VCC_OFFSET = 2.5

# ADS1115 Configuration
ADS1115_ADDRESS = 0x49  # Change to 0x48 if needed
ADS1115_GAIN = 1  # ±4.096V range (good for 0-5V sensors)

# ==============================================
# I2C BUS RESET FUNCTION (CRITICAL FOR RECOVERY)
# ==============================================

def reset_i2c_bus():
    """Manually reset I2C bus by toggling GPIO pins"""
    print("Attempting I2C bus reset...")
    try:
        # Import GPIO here to avoid issues if not available
        import RPi.GPIO as GPIO
        
        # Raspberry Pi I2C pins: GPIO2 (SDA), GPIO3 (SCL)
        SDA_PIN = 2
        SCL_PIN = 3
        
        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)
        
        # Set SDA as input first
        GPIO.setup(SDA_PIN, GPIO.IN)
        
        # Clock SCL until SDA goes high
        GPIO.setup(SCL_PIN, GPIO.OUT)
        
        for i in range(20):
            GPIO.output(SCL_PIN, GPIO.LOW)
            time.sleep(0.0001)
            GPIO.output(SCL_PIN, GPIO.HIGH)
            time.sleep(0.0001)
            
            # Check if SDA is high (bus free)
            if GPIO.input(SDA_PIN):
                break
        
        # Cleanup
        GPIO.cleanup()
        time.sleep(0.5)
        print("I2C bus reset completed")
        return True
        
    except Exception as e:
        print(f"I2C bus reset failed: {e}")
        return False

# ==============================================
# SAFE I2C INITIALIZATION
# ==============================================

def safe_i2c_init(max_attempts=3):
    """Initialize I2C with retry logic"""
    for attempt in range(max_attempts):
        try:
            print(f"Initializing I2C (attempt {attempt+1}/{max_attempts})...")
            i2c = busio.I2C(board.SCL, board.SDA, frequency=100000)  # Use slower 100kHz
            time.sleep(0.1)
            
            # Verify I2C is working
            while not i2c.try_lock():
                time.sleep(0.01)
            
            # Scan for devices
            devices = i2c.scan()
            i2c.unlock()
            
            print(f"I2C devices found: {[hex(x) for x in devices]}")
            
            if ADS1115_ADDRESS in devices:
                print(f"✓ ADS1115 found at {hex(ADS1115_ADDRESS)}")
                return i2c
            else:
                print(f"✗ ADS1115 not found at {hex(ADS1115_ADDRESS)}")
                if attempt == max_attempts - 1:
                    print("Trying alternative addresses...")
                    for addr in [0x48, 0x49, 0x4A, 0x4B]:
                        if addr in devices:
                            print(f"Found ADS1115 at {hex(addr)}, updating address")
                            global ADS1115_ADDRESS
                            ADS1115_ADDRESS = addr
                            return i2c
            
        except Exception as e:
            print(f"I2C init failed: {e}")
            if attempt < max_attempts - 1:
                time.sleep(1)
    
    # If we get here, all attempts failed
    print("ERROR: Could not initialize I2C")
    return None

# ==============================================
# SAFE ADS1115 INITIALIZATION
# ==============================================

def safe_ads1115_init(i2c, max_attempts=3):
    """Initialize ADS1115 with retry logic"""
    for attempt in range(max_attempts):
        try:
            print(f"Initializing ADS1115 (attempt {attempt+1}/{max_attempts})...")
            
            ads = ADS1115(i2c, address=ADS1115_ADDRESS)
            
            # Configure for stability
            ads.gain = ADS1115_GAIN
            ads.data_rate = 8  # Slow but stable: 8 samples/second
            
            # Test communication
            test_value = ads.read(0)
            print(f"ADS1115 test read (channel 0): {test_value}")
            
            # Initialize sensors
            v_sensor_1 = AnalogIn(ads, ads1x15.Pin.A0)
            v_sensor_2 = AnalogIn(ads, ads1x15.Pin.A1)
            curr_sensor = AnalogIn(ads, ads1x15.Pin.A2)
            
            print("✓ ADS1115 initialized successfully")
            return ads, v_sensor_1, v_sensor_2, curr_sensor
            
        except Exception as e:
            print(f"ADS1115 init failed: {e}")
            if attempt < max_attempts - 1:
                reset_i2c_bus()
                time.sleep(1)
    
    return None, None, None, None

# ==============================================
# SAFE SENSOR READING WITH VALIDATION
# ==============================================

def read_sensor_with_retry(sensor_func, sensor_name, max_attempts=3):
    """Read sensor with automatic retry on failure"""
    for attempt in range(max_attempts):
        try:
            value = sensor_func()
            
            # Basic validation
            if value is None:
                raise ValueError("No value returned")
                
            return value
            
        except (OSError, IOError, ValueError) as e:
            if attempt < max_attempts - 1:
                print(f"{sensor_name} read failed (attempt {attempt+1}): {e}")
                time.sleep(0.1 * (2 ** attempt))  # Exponential backoff
            else:
                print(f"ERROR: {sensor_name} read failed after {max_attempts} attempts")
                return None
    
    return None

# ==============================================
# VOLTAGE VALIDATION AND CALCULATION
# ==============================================

def validate_and_calculate_voltage(raw_voltage, battery_num):
    """Validate voltage reading and apply divider ratio"""
    if raw_voltage is None:
        return None
    
    # Convert to actual voltage
    actual_voltage = raw_voltage * VOLT_DIVIDER_RATIO
    
    # CRITICAL: Battery voltage should NEVER be negative
    if actual_voltage < 0:
        print(f"WARNING: Battery {battery_num} shows NEGATIVE voltage: {actual_voltage:.2f}V")
        print("This indicates WRONG POLARITY or WIRING ERROR!")
        print("Check your voltage sensor connections!")
        
        # For debugging, return absolute value but log error
        actual_voltage = abs(actual_voltage)
    
    # Sanity check: Li-ion batteries are 2.5V-4.2V
    if actual_voltage < 2.5 or actual_voltage > 4.5:
        print(f"WARNING: Battery {battery_num} voltage {actual_voltage:.2f}V outside expected range (2.5-4.5V)")
    
    return actual_voltage

def calculate_current(raw_voltage):
    """Calculate current from ACS712 with validation"""
    if raw_voltage is None:
        return None
    
    # ACS712 output should be between 0-5V
    if raw_voltage < 0 or raw_voltage > 5.0:
        print(f"WARNING: ACS712 voltage {raw_voltage:.2f}V outside expected range (0-5V)")
        return None
    
    # Calculate current
    current = (raw_voltage - VCC_OFFSET) / ACS_SENSITIVITY
    
    # Validate current reading
    if abs(current) > 30:  # Unrealistic for small DC motor
        print(f"WARNING: Unrealistic current: {current:.3f}A")
        return None
    
    return current

# ==============================================
# MAIN MONITORING LOOP
# ==============================================

def main():
    print("\n" + "="*60)
    print("RASPBERRY PI 5 BATTERY MONITORING SYSTEM")
    print("Robust Version with Error Recovery")
    print("="*60)
    
    # Initialize I2C
    i2c = safe_i2c_init()
    if i2c is None:
        print("FATAL: Cannot initialize I2C. Check connections and try again.")
        sys.exit(1)
    
    # Initialize ADS1115
    ads, v_sensor_1, v_sensor_2, curr_sensor = safe_ads1115_init(i2c)
    if ads is None:
        print("FATAL: Cannot initialize ADS1115. Check power and address.")
        sys.exit(1)
    
    print("\n" + "="*60)
    print("SYSTEM READY")
    print(f"Voltage Divider Ratio: {VOLT_DIVIDER_RATIO}")
    print(f"ACS712 Model: {ACS712_MODEL} ({ACS_SENSITIVITY} V/A)")
    print(f"Zero Current Offset: {VCC_OFFSET}V")
    print("="*60)
    print("\nStarting monitoring... (Press Ctrl+C to stop)\n")
    
    # Statistics
    read_count = 0
    error_count = 0
    max_errors_before_reset = 10
    
    try:
        while True:
            read_count += 1
            
            try:
                # Read all sensors with retry
                v1_raw = read_sensor_with_retry(
                    lambda: v_sensor_1.voltage, "Battery 1"
                )
                v2_raw = read_sensor_with_retry(
                    lambda: v_sensor_2.voltage, "Battery 2"
                )
                curr_raw = read_sensor_with_retry(
                    lambda: curr_sensor.voltage, "Current Sensor"
                )
                
                # Calculate actual values
                batt1_v = validate_and_calculate_voltage(v1_raw, 1)
                batt2_v = validate_and_calculate_voltage(v2_raw, 2)
                current_a = calculate_current(curr_raw)
                
                # Display results
                timestamp = time.strftime("%H:%M:%S")
                
                if batt1_v is None:
                    v1_display = "ERROR  "
                else:
                    v1_display = f"{batt1_v:5.2f}V"
                
                if batt2_v is None:
                    v2_display = "ERROR  "
                else:
                    v2_display = f"{batt2_v:5.2f}V"
                
                if current_a is None:
                    curr_display = "ERROR   "
                else:
                    curr_display = f"{current_a:6.3f}A"
                
                print(f"[{timestamp}] B1: {v1_display} | B2: {v2_display} | Current: {curr_display}")
                
                # Reset error count on successful read
                error_count = 0
                
                # Additional diagnostics every 10 readings
                if read_count % 10 == 0:
                    print(f"--- Diagnostics: {read_count} readings, {error_count} errors ---")
                    
                    # Show raw ADC values for debugging
                    try:
                        raw1 = v_sensor_1.value if v1_raw else 0
                        raw2 = v_sensor_2.value if v2_raw else 0
                        raw_curr = curr_sensor.value if curr_raw else 0
                        print(f"Raw ADC: B1={raw1}, B2={raw2}, Curr={raw_curr}")
                    except:
                        pass
                
                time.sleep(1.0)  # Update every second
                
            except KeyboardInterrupt:
                raise  # Re-raise to exit properly
                
            except Exception as e:
                error_count += 1
                print(f"\nERROR in main loop: {e}")
                print(f"Error count: {error_count}/{max_errors_before_reset}")
                
                if error_count >= max_errors_before_reset:
                    print("\nToo many errors! Attempting system recovery...")
                    reset_i2c_bus()
                    time.sleep(2)
                    
                    # Try to reinitialize
                    ads, v_sensor_1, v_sensor_2, curr_sensor = safe_ads1115_init(i2c)
                    if ads is None:
                        print("Recovery failed. Exiting.")
                        break
                    
                    error_count = 0
                    print("Recovery successful. Resuming monitoring...")
                
                time.sleep(2)  # Wait before retrying
                
    except KeyboardInterrupt:
        print("\n\nMonitoring stopped by user.")
        
    finally:
        print("\n" + "="*60)
        print("MONITORING STOPPED")
        print(f"Total readings: {read_count}")
        print(f"Total errors: {error_count}")
        print("="*60)

# ==============================================
# ENTRY POINT
# ==============================================

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"\nFATAL ERROR: {e}")
        traceback.print_exc()
        print("\nPlease check:")
        print("1. I2C connections (SDA, SCL, GND)")
        print("2. ADS1115 power (3.3V or 5V)")
        print("3. Sensor wiring polarity")
        print("4. Common ground connections")
```

## **Key Improvements in This Version:**

### **1. Error Recovery**
- Automatic I2C bus reset
- Retry logic for failed reads
- Graceful degradation instead of crashing

### **2. Wiring Validation**
- Detects negative voltages (wiring errors)
- Validates sensor ranges
- Provides diagnostic warnings

### **3. Stability**
- Slower I2C speed (100kHz)
- Slower sampling rate (8 SPS)
- Exponential backoff on errors

### **4. Diagnostics**
- I2C bus scanning
- Raw ADC values
- Error statistics

## **BEFORE RUNNING THE PROGRAM:**

### **Fix Your Wiring First!**

**Step 1: Disconnect everything and verify:**

```
Battery 1 (3.7V):
  Red wire → Voltage Sensor 1 VIN+
  Black wire → COMMON GROUND

Battery 2 (3.7V):
  Red wire → Voltage Sensor 2 VIN+
  Black wire → COMMON GROUND

COMMON GROUND (connect ALL these together):
  1. Battery 1 negative
  2. Battery 2 negative
  3. Raspberry Pi GND (pin 6, 9, 14, 20, 25, 30, 34, or 39)
  4. ADS1115 GND
  5. ACS712 GND
  6. Motor negative terminal

ACS712 Connections:
  VCC → 5V from Raspberry Pi or regulated source
  OUT → ADS1115 A2
  GND → COMMON GROUND
```

**Step 2: Test without motor:**
```bash
# Disconnect motor completely
# Run minimal test
python3 test_i2c.py
```

**Step 3: Run the corrected program:**
```bash
python3 safe_battery_monitor.py
```

**Your original program was fundamentally unsafe for real-world conditions. Use the corrected version above.**